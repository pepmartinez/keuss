"use strict";(self.webpackChunkkeuss_docusaurus=self.webpackChunkkeuss_docusaurus||[]).push([[4735],{1376:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/2024/01/23/queues-on-mongo-part-2","metadata":{"permalink":"/keuss/blog/2024/01/23/queues-on-mongo-part-2","editUrl":"https://github.com/pepmartinez/keuss/edit/master/website/blog/blog/2024-01-23-queues-on-mongo-part-2.md","source":"@site/blog/2024-01-23-queues-on-mongo-part-2.md","title":"Modelling queues on MongoDB - II","description":"This is a continuation of Modelling queues on MongoDB - I, where","date":"2024-01-23T00:00:00.000Z","formattedDate":"January 23, 2024","tags":[{"label":"mongodb","permalink":"/keuss/blog/tags/mongodb"},{"label":"tech","permalink":"/keuss/blog/tags/tech"}],"readingTime":7.89,"hasTruncateMarker":false,"authors":[{"name":"Pep Martinez","url":"https://github.com/pepmartinez"}],"frontMatter":{"title":"Modelling queues on MongoDB - II","author":"Pep Martinez","author_url":"https://github.com/pepmartinez","tags":["mongodb","tech"]},"nextItem":{"title":"Modelling queues on MongoDB - I","permalink":"/keuss/blog/2024/01/22/queues-on-mongo-part-1"}},"content":"This is a continuation of [Modelling queues on MongoDB - I](/blog/2024/01/22/queues-on-mongo-part-1), where\\nwe explained the technological basis on how to build a rather decent queue middleware by leveraging on preexisting\\nDB technologies, and adding very little more\\n\\nNow, we explore how to push the technology further, building on top of what we got so far to add extra, useful \\nfeatures\\n\\n## Adding delay/schedule\\nThis is a feature that is seldom found on QMWs, but that should be easy to implement if the \\npersistence is sound: after all, if you got the items safely stored, they can remain stored for\\nany arbitrary period of time\\n\\nThe tricky part is to provide this feature while honoring these conditions:\\n\\n* performance should not degrade. Both push and pop should remain `O(1)`\\n* items awaiting should not block items that are ready\\n\\nOn the other hand, this feature can be used to implement quite a lot of common logic, so it\\n_should_ be high in the wishlist. Some examples are:\\n\\n* [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff) if whatever you do \\nwith an item goes wrong and you want to retry later\\n* simple scheduling of events or actions (_items_ would model both)\\n* with some extra logic, it\'s easy to build a recurring or cron-like system, where items _happen_ \\nperiodically\\n\\nAs it turns out, this is quite easy to model on MongoDB while still maintaining all the features\\nand capabilities of the _good enough queues_ depicted before. The model can be expressed as:\\n\\n| operation | implementation base                                             |\\n|:---------:|:---------------------------------------------------------------:|\\n| push      | `coll.insertOne ({payload: params.item, when: params.when OR now()})`  |\\n| pop       | `coll.findOneAndDelete({when < now()}).payload`                 |\\n\\nOne of the obvious changes is, we no longer insert the item as is: we encapsulate it inside an _envelope_ where we put extra information; in this case, a timestamp stating when the object should start being elligible for a `pop` operation. Thus, the `pop` will only affect items whose `when` timestamp lies in the past, and ignore those with the timestamp still in the future\\n\\nThen, in order to keep the performance close to `O(1)` we must be sure the collection has an index on `when`; moreover, it would be advisable to also order the `findOneAndDelete` operation by `when`, descending: this way we will add best-effort ordering, where elements with a longer-due timestamp are popped first\\n\\n## Adding reserve-commit-rollback\\nA feture that should be offered on every decent QMW is the \\nability to reserve an item, then process it and commit it once \\ndone, or rollback it if something fails and we want it to be \\nretried later (or by other consumer)\\n\\nThis allows for what\'s known as _at-least-once_ semmantics: \\nevery item in the queue is guaranteed to be treated at least \\nonce even in the event of consumer failure. IT _does not_ \\nguarantee lack of duplications, though. By contrast, the simple _pop_ model provides _at_most_once_ semantics: duplications are \\nguaranteed to not to happen, but at the cost of risk of item \\nloss if a consumer malfunctions\\n\\nReserve-commit-rollback model cam be expressed as the following extension of the \\n_delay/schedule_ model above :\\n\\n| operation | implementation base                                                                                   |\\n|:---------:|:-----------------------------------------------------------------------------------------------------:|\\n| push      | `coll.insertOne ({payload: params.item, when: params.when OR now(), retries: 0, reserved: false})`           |\\n| pop       | `coll.findOneAndDelete({when < now()}).payload`                                                       |\\n| reserve   | `coll.findOneAndUpdate({when < now()}, {when: (now() + params.timeout), reserved: true})`                    | \\n| commit    | `coll.delete({_id: params.reserved._id})`                                                                    | \\n| rollback  | `coll.findOneAndUpdate({_id: params.reserved._id}, {when: (now() + params.delay), reserved: false, retries: $inc})` |\\n\\nThe general idea is to leverage the existing scheduling fature: to reserve an element is just to set its `when`\\ntime ahead in the future, by a fixed `timeout` amount; if the consumer is unable to process the element in this \\ntime, the item will become elligible again for other consumers.\\n\\nThe `commit` operation simply deletes the entry by using the `_id` of the element returned by \\n`reserve`; and the `rollback` is a bit more complex: it modifies it to remove the `reserved` flag, increments\\nthe `retries` counter and -most important- sets a `when` time further in the future. This last bit fulfills\\nthe mprotant feature of adding delays to retries, so an element rejected by a consumer for further retry \\nwill not be available immediately (when it is likely to fail again)\\n\\nNote that the `reserved` flag is purely informational, although further checks could be done on it to improve\\nrobustness. The same goes for `retries`: it just counts the number of retries; more logic could be added to this,\\nfor example adding a _dead-queue_ feature: if the number of retries goes too high the items are moved to a \\nseparated queue for a more dedicated processing at a later time\\n\\n## Queues with historic data\\nHere\'s another twist: instead of fully removing items once consumed (by means f `pop` or `commit`), we just mark \\nthem as deleted; then we keep them around for som etime, just in case we need to inspect past traffic, or replay \\nsome items. This feature can be desirable on environments where the ability to inspect or even reproduce past traffic\\nis paramount. Also, this can be easily done at the expense of storage space only, with the following variation over\\nthe model above:\\n\\n| operation | implementation base                                                                                         |\\n|:---------:|:-----------------------------------------------------------------------------------------------------------:|\\n| push      | `coll.insertOne ({payload: params.item, when: params.when OR now(), retries: 0, reserved: false})`                 |\\n| pop       | `coll.findOneAndUpdate({when < now(), processed: $nonexistent}, {processed: now(), when: $INF}).payload`    |\\n| reserve   | `coll.findOneAndUpdate({when < now(), processed: $nonexistent}, {when: (now() + params.timeout), reserved: true})` | \\n| commit    | `coll.update({_id: params.reserved._id}, {processed: now(), when: $INF})`                                          | \\n| rollback  | `coll.findOneAndUpdate({_id: params.reserved._id}, {when: (now() + params.delay), reserved: false, retries: $inc})`       |\\n\\nThen, we need to add a [TTL index](https://www.mongodb.com/docs/manual/core/index-ttl/) on the new field `processed`, with \\nsome long-enough expiration time\\n\\nThe main difference is the addition of a `processed` field that marks both whether the item was processed (that is _deleted_,\\n_no more_, _gone to meet its maker_) and if so, when that happened. This field is also used to delete old entries, once some\\nfixed time has elapsed. This means those queues can potentially grow very big, cause the condition to remove old entries is \\nage, and not size\\n\\nNote that, in order to improve performance a bit, when an element is processed (after either _pop_ or _commit_) its _when_ is\\nset to some time far in the future, to move it \'away\' of the _get_/_reserve_ query\\n\\n## Queues fit for ETL pipelines: moving elements from one queue to the next, atomically\\n\\nHtis is an interesting concept: one of the common uses of job queues is to build what\'s known as ELT pipelines: a set of \\ncomputing stations where items are transformed or otherwise processed, connected with queues. A common example would be \\na POSIX shell pipeline, where several commands are tied together so the output of one becomes the input of the next; a \\nETL pipeline can have also forks and loops, so the topology can be generalized to a graph, not just a linear pipeline\\n\\nLet us assume for a moment that messages are never created or duplicated in any station: in other words, an item entering \\na station will produce zero or one items as output. In this scenario, oen of the reliability problems that arise is that, \\nusually, moving items from one (input) queue to the next (output) queue is not an atomic operation. This may lead to either item loss or item duplication in the case of station\\n malfunction, even if we use `reserve-commit`\\n\\nIf we push to output after committing on input, we incur on risk of loss:\\n\\n  ```mermaid\\n  sequenceDiagram\\n    autonumber\\n    participant input-queue\\n    participant station\\n    participant output-queue\\n    station->>+input-queue: reserve\\n    input-queue->>-station: element\\n    activate station\\n    note right of station: process element\\n    station->>-input-queue: commit\\n    activate input-queue\\n    input-queue->>station: ack\\n    deactivate input-queue\\n    note left of input-queue: element is no longer in queue\\n    note right of station: potential to item loss here\\n    station->>+output-queue: push\\n  ```\\n\\nwhereas if we push to output _before_ commit on input, we risk duplication:\\n  ```mermaid\\n  sequenceDiagram\\n    autonumber\\n    participant input-queue\\n    participant station\\n    participant output-queue\\n    station->>+input-queue: reserve\\n    input-queue->>-station: element\\n    activate station\\n    note right of station: process element\\n    note left of input-queue: element is still in queue\\n    station->>+output-queue: push\\n    note right of station: potential to item duplication here\\n    station->>-input-queue: commit\\n    activate input-queue\\n    input-queue->>station: ack\\n    deactivate input-queue\\n    station->>+output-queue: push\\n  ```\\n\\nSo, the _commit-in-input_ and _push-on-output_ operations must be done atomically; and it turns out it is quite simple \\nto extend the model to accomodate that as a new, atomic _move-to-queue_ operation (although it comes at a price, as we \\nwill see)\\n\\nThis new operation requires that _all_ queues of a given pipeline have to be hosted in the same mongodb collection; so, \\nour item envelope grows to contain an extra field, `q`. Then, all operations are augmented to use this new field:\\n\\n| operation | implementation base                                                                                   |\\n|:---------:|:-----------------------------------------------------------------------------------------------------:|\\n| push      | `coll.insertOne ({q: params.qname, payload: params.item, when: params.when OR now(), retries: 0, reserved: false})` |\\n| pop       | `coll.findOneAndDelete({q: params.qname, when < now()}).payload`                                             |\\n| reserve   | `coll.findOneAndUpdate({q: params.qname, when < now()}, {when: (now() + params.timeout), reserved: true})`          | \\n| commit    | `coll.delete({_id: params.reserved._id})`                                                                    | \\n| rollback  | `coll.findOneAndUpdate({_id: params.reserved._id}, {when: (now() + params.delay), reserved: false, retries: $inc})` |\\n\\nThe new operation _move-to-queue_ is expected to act upon a reserved item, and can be modelled as:\\n\\n| operation | implementation base                                                                                   |\\n|:---------:|:-----------------------------------------------------------------------------------------------------:|\\n| moveToQ   | `coll.findOneAndUpdate({_id: params.reserved._id}, {q: params.new_qname, reserved: false, retries: 0})`  |\\n\\nThe operation is rather similar to a rollback, and it is definitely atomic"},{"id":"/2024/01/22/queues-on-mongo-part-1","metadata":{"permalink":"/keuss/blog/2024/01/22/queues-on-mongo-part-1","editUrl":"https://github.com/pepmartinez/keuss/edit/master/website/blog/blog/2024-01-22-queues-on-mongo-part-1.md","source":"@site/blog/2024-01-22-queues-on-mongo-part-1.md","title":"Modelling queues on MongoDB - I","description":"This is a series of articles describing the technical details on which keuss is based to build a rather complete","date":"2024-01-22T00:00:00.000Z","formattedDate":"January 22, 2024","tags":[{"label":"mongodb","permalink":"/keuss/blog/tags/mongodb"},{"label":"tech","permalink":"/keuss/blog/tags/tech"}],"readingTime":17.465,"hasTruncateMarker":false,"authors":[{"name":"Pep Martinez","url":"https://github.com/pepmartinez"}],"frontMatter":{"title":"Modelling queues on MongoDB - I","author":"Pep Martinez","author_url":"https://github.com/pepmartinez","tags":["mongodb","tech"]},"prevItem":{"title":"Modelling queues on MongoDB - II","permalink":"/keuss/blog/2024/01/23/queues-on-mongo-part-2"},"nextItem":{"title":"New website!","permalink":"/keuss/blog/2020/08/04/welcome"}},"content":"This is a series of articles describing the technical details on which `keuss` is based to build a rather complete\\nqueue middleware (`QMW` henceforth) with a quite shallow layer on top of `MongoDB`. The basic approach is well known and understood, but\\n`keuss` goes well beyond the basic approach to provide extra functionalities\\n\\n## Some nomenclature\\n\\nLet us start establishing some common nomenclature that will appear later on:\\n\\n* ***job queue***: A construct where elements can be inserted and extracted, in a FIFO (first in, first out) manner. Elements \\n  extracted are removed from the queue and are no longer available\\n* ***queue middleware (qmw)***: A system that provides queues and means for actors to perform as producers, consumers or both\\n* ***push***: action of inserting an element into a queue\\n* ***pop***: action of extracting an element from a queue\\n* ***reserve/commit/rollback***: operations to provide more control on the extraction of elements: first the element is _reserved_,\\n  (making it invisible by other reserve or pop operations, but still present in the queue), then once the element is processed it is _committed_ (and only then the element is removed from the queue) or _rolledback_ (meaning it is made elligible again for other reserve or pop, possibly after some delay); if none of _commit_ or _rollback_ happen after some time, an automatic _rollback_ is applied.\\n* ***consumer***: an actor performing pop and/or reserve-commit-rollback operations on a queue. A queue can have zero or more concurrent consumers\\n* ***producer***: an actor performing push operations on a queue. A queue can have zero or more concurrent producers\\n* ***at-most-once***: consumer guarantee associated with the `pop` operation: since the element is first removed from the queue, and\\n  then the consumer proceeds to process it, if the consumer dies or crashes in between the element will be lost. That is, losses are\\n  tolerated, but duplications are not\\n\\n  ```mermaid\\n  sequenceDiagram\\n    autonumber\\n    participant queue\\n    participant consumer\\n    consumer->>+queue: pop\\n    queue->>-consumer: element\\n    activate consumer\\n    note left of queue: element is no longer in queue\\n    note right of consumer: process element\\n    deactivate consumer\\n    note right of consumer: element processed, get another\\n    consumer->>+queue: pop\\n    queue->>-consumer: element\\n    \\n  ```\\n\\n* ***at-least-once***: consumer guarantee associated with the `reserve-commit-rollback` operations: if the consumer crashes between\\n  `reserve` and `commit` the element will eventually be auto-rolledback and be processed again (possibly by another consumer). \\n  Therefore, duplications are tolerated but losses are not\\n\\n  ```mermaid\\n  sequenceDiagram\\n    autonumber\\n    participant queue\\n    participant consumer\\n    consumer->>+queue: reserve\\n    queue->>-consumer: element\\n    activate consumer\\n    note left of queue: element is still in queue, but not accesible to other consumers\\n    note right of consumer: process element\\n    consumer->>-queue: commit\\n    activate queue\\n    queue->>consumer: ack\\n    deactivate queue\\n    note left of queue: element is no longer in queue\\n    note right of consumer: element processed, get another\\n    consumer->>+queue: pop\\n    queue->>-consumer: element\\n  ```\\n\\n* ***exactly-once***: theoretical consumer guarantee where no losses and no duplications can happen. It involves the use ot monotonical \\n  identifiers or window-based duplication detection, and is generally extremelly complex to achieve, and almost in all cases with a\\n  hefty performance penalty. It is almost never offered out fo the box in any QMW\\n* ***deadletter queue***: usually, there is a maximum number of times an element can be rolled back after a reserve, in order to prevent \\n  ill-formed or otherwise incorrect messages to stay forever in queues. Upon rollback, if the element has reached the maximum number of\\n  rollbacks it is remove from the queue and pushed into the deadletter queue, which is an otherwise regular queue\\n* ***ordered queue***:  A non-FIFO queue: insertions are not done at the tail of the queue, but at any point. This means insertions are \\n  no longer _O(1)_: depending on the technology used they can be _O(n_) or better, such as _O(log(n))_ for a btree-based queue; same goes for \\n  push/reserve operations, they are no longer _O(1)_.\\n\\n  Using ordered queues on a QMW is key to implement certain operations: not only the more obvious such as delay, schedule or priorities,\\n  but also robust and performing reserve/commit/rollback\\n  \\n  Using a database to implement queues makes ordered queues a bliss: using a regular index is usually all you need to get\\n  near-constant-complexity operations\\n* ***delay/schedule***: Push operation when the element is marked to not to be elligible for pop or reserve _before_ a certain time. \\n  The presence of delayed elements must not impact in any way the rest of elements (that is, the rest of elements\' elligibility must not\\n  change) or the queue itself (that is, que presence of delayed elements must not degrade the queue performance or capabilities)\\n\\n  This feature can be very easily implemented using an ordered queue, where the order is defined by a timestamp representing the \\n  _mature_ time: the time when the element can be popped or reserved, and not before\\n\\n  The delay/schedule feature can be applied also to rollbacks, since a rollback is conceptually a re-insertion; delays in rollbacks\\n  provide a way to implement [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff) easily, to prevent busy \\n  reserve-fail-rollback loops when only one element is in the queue, and the element is repeteadly rolled back upon processing\\n\\n## Basic building blocks\\n\\nHere\'s what you need to build a proper QMW:\\n\\n1. A ***storage subsystem***: Data for the contents of the queues have to be stored somewhere. It has to provide:\\n    1. **Persistency**: data must be stored in a permanent manner, realiably. In-memory QMW has its niche, but we will\\n       focus on _persistent_ QMWs\\n    2. **High Availability**: we do not want a hardware or network failure to take down the QMW. It should run in a _cluster_ \\n       manner, on several machines (possibly in separated geographical locations); if one of the machines fail the rest\\n    can cope without (or with minimal) disruption\\n    3. **Sufficient Throughput**: the storage should be able to handle a high number of operations per second\\n    4. **Low Latency**: operations should be performed very fast, ideally as independent of throughput as possible\\n\\n2. An ***event bus***: all QMW clients would need some form of central communication to be aware of certain events in the \\n   QWM. For example, if a client is waiting for data to become available in a queue, it should be able to simply await for\\n   an event, instead of running a poll busy-loop. Another example  of useful event is to signal whether a queue becomes \\n   paused (since it must be paused for _all_ clients)\\n\\n   This event bus can be a _pub/sub_, stateless bus: only connected clients are made aware of events and there is no need to save\\n   events for clients that may connect later. This simplifies the event bus by a lot.\\n\\nThe whole idea behind `keuss` is that all those building blocks are already available out there in the form of DataBase\\nsystems, and all there is to add is a thin layer and a few extras.\\n\\n## The need for atomic operations\\n\\nHowever, not just *any* storage (or DB, for that matter) is a good candidate to model queues: there is at least one feature\\nthat, lest it be present, renders queue modelling very difficult if not impossible: _atomic modify operations_\\n\\nAn atomic modify operation in the context of a storage system can be defined as the ability to perform a read and a modify \\non a single record without the possibility of a second modify interfering, changing the record after the read but before \\nthe modify (or after the modify and before the read)\\n\\nIf the storage system provides such primitives, it is relatively easy and simple to model queues on top of it; also, the \\noverall performance (throughput and latency) will greatly depend on the performance of such operation: most RDBMs can do\\nthis by packing the read and the modify inside a _transaction_, but that usually degrades the performance greatly, to a\\npoint where it is not viable for queue modelling\\n\\nThere are 2 major storage systems that provide all the needed blocks, along with atomic modifies: `MongoDB` and `Redis`.\\n`MongoDB` has turned out to be an almost perfect fit to back a QMW, as we shall see. `MongoDB` provides a set of atomic \\noperations to read and modify, and to read and remove. Those operations guarantee that the elements selected to be read \\nand then modified (or removed) will not be read by others until modified (or not read at all if it\'s removed)\\n\\n`Redis` is also a good fit, but it does nor provide a good enough storage layer: it is neither persistent nor high available. \\nArguably, that\'s a default behaviour: `Redis-Cluster` coupled with proper persistency should in theory be up to the task. \\nHowever, this series of articles would focus on `MongoDB` only. For now, let us say that atomic operations are very easily\\nadded to `Redis` by coding them as `lua` extensions, since all operations in `Redis` are atomic by design\\n\\nIn the following sections we will see how the implementations of common QMW operations can be indeed solved elegently using\\natomic operations provided by MongoDB as the underlying DB/storage\\n\\n## Simple approach: good enough queues\\n\\nThere is a very simple, very common way to model queues on top of mongoDB collections. This model does not support \\nreserve-commit-rollback, nor it does support delay/schedule. The model can be succintly put as:\\n\\n| operation | implementation base       |\\n|:---------:|:-------------------------:|\\n| push      | `coll.insertOne (item)`   |\\n| pop       | `coll.findOneAndDelete()` |\\n\\nThe key is the use of the atomic operation `findOneAndDelete`, which is the combination of a `findOne` and a `remove`, but \\nrun in one single step. Several actors can perform concurrent `findOneAndDelete` operations without issues, and without \\ninterfering each other\\n\\nActors can perform concurrent `insertOne` operations too, without interference; the same goes for actors performing _both_\\n`findOneAndDelete` and `insertOne` operations. The net result is that many consumers and producers can be served concurrently\\nwithout interferences or loss of performance, which is what one expects of any self-respecting QMW\\n\\nThis model provides a very simple but rather capable powerful QMW:\\n\\n* queues are _mostly_ strict FIFO (FIFO loses its strict meaning when different producers located in different machines\\n  are inserting in the same queue, but in practical terms it usually does not matter)\\n* we got very good persistence, as good as mongodb\'s\\n* we got very good HA:\\n  * both consumers and producers have no state, so they can be replicated without problems\\n  * there is a practical 1:1 equivalence between queues and collections, so all the HA guarantees mongodb provides on \\n    collections apply directly to queues\\n* we got more than decent performance:\\n  * mongodb is quite performing on insertions, in the range of Khz (ie, thousands per second)\\n  * on pop operations, `findOneAndDelete` is less performing than a simple `remove` or a `findOne` but is still able to \\n    reach Khz performance. In practice, `findOneAndDelete` is the bottleneck of this model, because it serializes calls \\n    to `pop` within each queue\\n\\nThe main drawback of this model is the fact that the pop/reserve operations can only be performed in a poll loop: they \\neither return an element or return \'no elements in queue\' (or return an error), in all cases pretty mich immediately. \\nTherefore, wait state of arbitrary duration must be inserted in the consumer loop if the operation returns \'no elements in queue\': \\notherwise you will get a busy loop where your pop/reserve call relentlessly return \'no elements\', eating the CPU in the\\nprocess (incidentally, this is a text-book case of poll loop)\\n\\nIn some cases, where latencies in the range of seconds or tens of seconds are of no concern, a pool loop can be happily\\nused, so this makes a valid, simple and effective model, especially if you already use MongoDB. In cases where latencies\\nare expected to be near-realtime something better is needed\\n\\n## Adding an event bus\\n\\nAt this point, one of the best improvements to the model is to remove the need for poll loops; for that to happen, we \\nneed the pop/reserve operations to \'block\' if there are no elements, until they are. A na\xefve way to do so is to add the\\npoll loop in the pop/reserve calls, so the caller would have the _illusion_ of blocking:\\n\\n  ```mermaid\\n  sequenceDiagram\\n    autonumber\\n    participant queue\\n    participant consumer\\n    participant caller\\n    caller->>consumer: pop\\n    consumer->>queue: pop\\n    queue->>consumer: no elements\\n    note right of consumer: wait a fixed period, then try again\\n    consumer->>queue: pop\\n    queue->>consumer: no elements\\n    note right of consumer: wait a fixed period, then try again\\n    note left of queue: someone else inserts at least one element\\n    consumer->>queue: pop\\n    queue->>consumer: element\\n    consumer->> caller: element\\n  ```  \\n\\nAs mentioned, this simply moves the pool loop inside the pop/reserve implemenation, away from the user\'s eyes. But it\\nis still a poll loop, with all its limitations. To truly remove the poll loop we need the ability to _wake up_ a waiting\\nconsumer _when_ there are new elements in the queue:\\n\\n  ```mermaid\\n  sequenceDiagram\\n    autonumber\\n    participant producer\\n    participant queue\\n    participant consumer\\n    participant caller\\n    caller->>consumer: pop\\n    consumer->>queue: pop\\n    queue->>consumer: no elements\\n    note right of consumer: wait until woken up\\n    producer->>queue: push\\n    note right of queue: now we got elements\\n    queue--\x3e>consumer: wake-up, elements available \\n    consumer->>queue: pop\\n    queue->>consumer: element\\n    consumer->> caller: element\\n  ``` \\n \\nThis way the push-to-pop latencies are reduced to close to the theoretical minimum: any consumer would be blocked only when\\nthey have to: when there are no elements\\n\\n### Possible implementations\\nThere is an obvious option for the implementation of such an event bus: a pub/sub subsystem. Pub/sub is very well understood, \\nit\'s stateless and there are a lot of stable implementations. And more importantly, there are stable implementations _on top_\\nof we already use for storage of queues.\\n\\nThe main disadvantages of pub/sub in themselves as event bus are:\\n* they can not handle duplicates: in an HA setup all the replicas of a given client will get a separated copy of each event\\n* they have no history: disconnected clients will miss any event published when they\'re not connected\\n\\nBut none of those is a real disadvantage for us:\\n* each client, whether a replica or not, _must_ receive a copy of each event\\n* disconnected clients do not need to receive and react to events, since they\'re not dealing with queues\\n\\nLet\'s see the most viable implementations:\\n#### In-memory pub/sub\\nThis is a very simple, extremely nimbre implementation of a pub/sub that works only within the same (OS) process. It\'s only \\nmeant to be used for testing. It can be also seen as the _canonical_ implementation of the event bus\\n\\nA very good and very simple implementation for node.js is [mitt](https://www.npmjs.com/package/mitt)\\n\\n#### Redis pub/sub\\n`redis` offers a simple and very efficient [pub/sub implementation](https://redis.io/docs/manual/pubsub/), which can be used \\nas is. If you already use redis it\'s definitely the way to go\\n\\n#### MongoDB capped collection (also a pub/sub)\\nSince `mongoDB` is used to back the queues, it would be great if it could also power the rest of the needed subsystems; and it does,\\nwith a just a little implementation work: it is relatively easy to build a pubsub on top of \\n[mongoDB capped collections](https://www.mongodb.com/docs/upcoming/core/capped-collections/), and there are quite a few \\nimplementations readily available. One good example of such implementation in node.js is [mubsub](https://www.npmjs.com/package/@nodebb/mubsub)\\n\\nUsing this implementation has the added appeal of not adding any extra dependency: you can just use the same mongoDB server used for\\nthe queues\\n\\nThis implementations has the added benefit of _history state_: it operates like a ring buffer, so there is the possibility of \\naccessing past events. However, this is not needed at all here\\n\\n### Practical considerations & improvements\\nThere are a few considerations worth noting about how pubsub fits our purpose, and a few extras we can add to improve matters further\\n\\n#### Race conditions\\nA pubsub bus is asynchronous in nature, so under some conditions you may lose events. Take for example the case of a single client\\nthat reinserts an element in the same queue it is consuming from: the event fired upon the insertion is produced at about the same time\\nthe client attempts to pop another element. However, if the pop operation establishes the queue is empty (because the queue size was \\nnot yet updated after the insert) but the event arrives before the pop operation starts waiting for them, you lose the event and you \\nrisk waiting forever, when the queue has indeed one element\\n\\n```mermaid\\n  sequenceDiagram\\n    autonumber\\n    participant queue\\n    participant consumer\\n    consumer->>queue: pop\\n    queue->>consumer: element\\n    consumer->>queue: push a new element\\n    queue--\x3e>consumer: wake-up, elements available \\n    consumer->>queue: pop\\n    note right of consumer: it might see the queue empty\\n    note right of consumer: it might lose the wake-up event\\n    note left of queue: waits indefinitely\\n```\\n\\nRace conditions such as this one are very hard to prevent entirely, if at all possible. For that reason it is recommended to use\\na model in which race conditions do not cause major issues\\n\\nIn a system such as a `QMW` the problems to avoid at all costs are:\\n* loss of messages\\n* duplication of messages\\n* deadlocks and other forms of wait-forever conditions\\n\\nRace conditions on wake-up events won\'t cause loss or duplications of messages, since this is guaranteed by the queue model; they can\\nhowever cause deadlocks, where a consumer is left waiting forever for an event that may never arrive\\n\\nOne way to remove this problem is to add a timeout and a poll loop: in the absence of events, the consumer will fallback into a poll\\nloop with a rather long period (this period would be the wait-for-events timeout), usually in the range of tens of seconds. With this\\nwe change deadlocks into poll cycles, or deadlocks into increased latency for some rare cases\\n\\nThe consume pop loop would look like this:\\n```\\nforever do:\\n  msg := pop_msg_from_queue()  // nonblocking operation, either returns a message or null if none available\\n  if (!msg) do:\\n    await wake_up(insertion) or timeout(period)\\n    continue // a wakeup event arrived or the the timeout was reached: next loop either way\\n  else\\n    return msg\\n  done\\ndone\\n```\\n\\n#### High cardinality of events\\nA side effect of having \'insert\' events published is that subscribers must be ready to deal with potentially enormous amounts of events;\\nif you\'re inserting messages in queues at, say 1 Khz and you have 50 consumers, you will have 50,000 individual events to deal with. \\nBesides, most of thos events will add no information at all: once a consumer is woken up, it would not be interested in insert events until the queue is empty again; queue consumers jsut ignore events emitted when they are not idle, but the raw amount of events in the\\nbus might still need a noticeable amount of compute and I/O (especially on non-local pubsubs)\\n\\nA simple way to minimize this is to simply ignore events if an equivalent one was emitted already in a short period of time; if that is\\nthe case, the event is ignored right before the publish, and does not make it to the pubsub at all\\n\\nKeuss uses exactly this strategy on all the included signal pubsubs, using a window of 50 ms: if the same event was emitted for the same queue within 50 ms in the past, it is ignored\\n\\n##### Drawbacks\\nThis strategy has a notable drawback: it introduces an apparent race condition. \\n\\nTake a queue with a single consumer; insert a single message in the queue, which would be immediately taken by the consumer. If the \\nconsumer rejects the message with a zero delay, the consumer may still see zero elements in the next iteration, so it\'ll block and \\nwait for insert events. The reject will indeed produce an insert event... which will be dropped because it\'s equivalene to the first\\ninsert event, that was emitted about the same millsecond\\n\\nThis will just be a nuisance, since the consumer would time out and rearm itself eventually. But be warned, this can happen on edge \\ncases\\n\\n#### Adding another pub/sub implementation\\nThe interface for pubsub in Keuss is very simple, so adding new or different implementations would be quite easy. For example, if\\nyou already use `mqtt`, it makes sense to reuse it to power the event pubsub. This is however out of scope\\n\\n### Final thoughts\\nAt this point we got a rather decent QMW capable of push/pop with concurrent pubishers and consumers, with persistence and HA, and \\nable to manage operations at Khz frequency with millisec latencies; all this with a quite simple and stateless implementation\\n\\nThis model can already solve a great deal of problems where persistent job queues are needed, especially if you already got MongoDB\\nin your mix. Also, it has 2 advantages over tradicional QMWs :\\n\\n1. _Performance_: This model produces great performance figures when compared with tradicional QMWs with full persistence/HA activated\\n2. _Simplicity_: the whole of the implementation is client side, and it is stateless and very thin. \\n3. _Ease of debug_: it is very easy to _open the trunk_, peek inside and see exactly what\'s in each queue, and it equally easy to tweak\\n   and fix whatever problem you find. In some situations this is an invaluable feature\\n\\nHowever, we can [do better](/blog/2024/01/23/queues-on-mongo-part-2)..."},{"id":"/2020/08/04/welcome","metadata":{"permalink":"/keuss/blog/2020/08/04/welcome","editUrl":"https://github.com/pepmartinez/keuss/edit/master/website/blog/blog/2020-08-04-welcome.md","source":"@site/blog/2020-08-04-welcome.md","title":"New website!","description":"We got a brand new site for Keuss, powered by Docusaurus v2. Chances are, if you\'re reading this, you already found the site...","date":"2020-08-04T00:00:00.000Z","formattedDate":"August 4, 2020","tags":[{"label":"keuss","permalink":"/keuss/blog/tags/keuss"},{"label":"hello","permalink":"/keuss/blog/tags/hello"},{"label":"docusaurus","permalink":"/keuss/blog/tags/docusaurus"}],"readingTime":0.33,"hasTruncateMarker":false,"authors":[{"name":"Pep Martinez","url":"https://github.com/pepmartinez"}],"frontMatter":{"title":"New website!","author":"Pep Martinez","author_url":"https://github.com/pepmartinez","tags":["keuss","hello","docusaurus"]},"prevItem":{"title":"Modelling queues on MongoDB - I","permalink":"/keuss/blog/2024/01/22/queues-on-mongo-part-1"}},"content":"We got a brand new site for Keuss, powered by [Docusaurus v2](https://v2.docusaurus.io). Chances are, if you\'re reading this, you already found the site...\\n\\nGood old README.md, as simple and convenient as it is, was becoming way too big and difficult to navigate. Also, it is not a proper site worth presenting to the world; hence the decision to add a small, simple enough site to Keuss"}]}')}}]);