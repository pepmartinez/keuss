"use strict";(self.webpackChunkkeuss_docusaurus=self.webpackChunkkeuss_docusaurus||[]).push([[1643],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>c});var n=r(7294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function a(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var l=n.createContext({}),u=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):a(a({},t),e)),r},p=function(e){var t=u(e.components);return n.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=u(r),c=o,h=m["".concat(l,".").concat(c)]||m[c]||d[c]||i;return r?n.createElement(h,a(a({ref:t},p),{},{components:r})):n.createElement(h,a({ref:t},p))}));function c(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=r.length,a=new Array(i);a[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,a[1]=s;for(var u=2;u<i;u++)a[u]=r[u];return n.createElement.apply(null,a)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"},4346:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>u});var n=r(7462),o=(r(7294),r(3905));const i={id:"map-of-strict-ordered-queues",title:"Map of Strict Ordered Queues",sidebar_label:"Map of Strict Ordered Queues"},a=void 0,s={unversionedId:"Usage/Experiments-and-Curiosities/map-of-strict-ordered-queues",id:"Usage/Experiments-and-Curiosities/map-of-strict-ordered-queues",title:"Map of Strict Ordered Queues",description:"The problem",source:"@site/docs/04-Usage/08-Experiments-and-Curiosities/01-map-of-strict-ordered-queues.md",sourceDirName:"04-Usage/08-Experiments-and-Curiosities",slug:"/Usage/Experiments-and-Curiosities/map-of-strict-ordered-queues",permalink:"/keuss/docs/Usage/Experiments-and-Curiosities/map-of-strict-ordered-queues",draft:!1,editUrl:"https://github.com/pepmartinez/keuss/edit/master/website/docs/04-Usage/08-Experiments-and-Curiosities/01-map-of-strict-ordered-queues.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"map-of-strict-ordered-queues",title:"Map of Strict Ordered Queues",sidebar_label:"Map of Strict Ordered Queues"},sidebar:"tutorialSidebar",previous:{title:"Stream-mongo backend",permalink:"/keuss/docs/Usage/Streaming/stream-mongo"},next:{title:"Examples",permalink:"/keuss/docs/examples"}},l={},u=[{value:"The problem",id:"the-problem",level:2},{value:"Possible solutons",id:"possible-solutons",level:2}],p={toc:u};function d(e){let{components:t,...r}=e;return(0,o.kt)("wrapper",(0,n.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"the-problem"},"The problem"),(0,o.kt)("p",null,"There is a real-life requirement that sometimes appears on systems using queues to deliver or receive asynchronous notifications: a certain local ordering is needed, so certain notifications must be delivered strictly after others, all of this while respecting asynchronicity on the larger scale"),(0,o.kt)("p",null,"A good example of that would be delivering state-change notifications on entities such as phone calls: one would rather keep strict order on events within a single call, so you would not receive, for example,  a 'caller-pushed-#7' event after receiving 'call-ended'. Also, any block of delay enforced by the orderng on call A should not impact, delay or block call B or any other call"),(0,o.kt)("h2",{id:"possible-solutons"},"Possible solutons"),(0,o.kt)("p",null,"This is a complex problem, since it is generally difficult - if not impossible - to ascertain whether you should wait longer for delayed events yet to appear. The general approach is usually a combination of any of these:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"retrofit delayed events arriving out of order, thus modifying state ",(0,o.kt)("em",{parentName:"li"},"post hoc")),(0,o.kt)("li",{parentName:"ol"},"use strict sequence counters when the events are produced, so spotting a hole becomes easy"),(0,o.kt)("li",{parentName:"ol"},"add the needed ",(0,o.kt)("em",{parentName:"li"},"wait-and-reorder")," of events at the consumer end; this usually invvolves setting a set of\nstrict-order queues, one per emitting entity")),(0,o.kt)("p",null,"None of those approaches is perfect, every each of them has its own problems:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"#1 : It may not be possible to ",(0,o.kt)("em",{parentName:"li"},"go back in time")," and anyway it'll imply keeping state or history of such past"),(0,o.kt)("li",{parentName:"ul"},"#2 : if the events can come from more than one source it may be next to impossible to produce a common, strict\nmonotonical sequence counter"),(0,o.kt)("li",{parentName:"ul"},"#3: this is usually just another way to reformulate #1, by holding all the state received until it can be assumed\nit can be emitted and used without risk for ",(0,o.kt)("em",{parentName:"li"},"post hoc")," modifications later on")),(0,o.kt)("p",null,"So, assuming we're dealing with a problem with no practical an complete solution, we might as well try to produce a partial solution embedded in the queuing middleware"),(0,o.kt)("h1",{id:"a-partial-solution-in-keuss-map-of-queues"},"A partial solution in Keuss: Map Of Queues"),(0,o.kt)("p",null,"The implementation comes in the form of a queue backend named ",(0,o.kt)("inlineCode",{parentName:"p"},"intraorder"),", backed by ",(0,o.kt)("inlineCode",{parentName:"p"},"mongodb")," and works as follows:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"All items in a queue will provide a ",(0,o.kt)("em",{parentName:"li"},"grouping identifier"),", which is expected at the field ",(0,o.kt)("inlineCode",{parentName:"li"},"iid")),(0,o.kt)("li",{parentName:"ul"},"When an item is pushed in a queu where other items already exist with the same ",(0,o.kt)("inlineCode",{parentName:"li"},"iid"),", it is ",(0,o.kt)("em",{parentName:"li"},"guaranteed")," that this item\nwill not be served until the already-existing items are gone (popped, committed or moved to deadletter)"),(0,o.kt)("li",{parentName:"ul"},"The former is true also in the presence of retries and delays: if an item is rolled back, it will block\nany other item with the same ",(0,o.kt)("inlineCode",{parentName:"li"},"iid")," that happened to be pushed after"),(0,o.kt)("li",{parentName:"ul"},"Also, delays on insertion of elements are honored (as they are on retries), but they will also block further elements\nwith the same ",(0,o.kt)("inlineCode",{parentName:"li"},"iid")," until the element is removed from the queue")),(0,o.kt)("p",null,"This provides a partial solution to the problem, in the sense that a strict ordering within same ",(0,o.kt)("inlineCode",{parentName:"p"},"iid")," is imposed ",(0,o.kt)("em",{parentName:"p"},"for elements not extracted from the queue"),"  "),(0,o.kt)("h1",{id:"caveats"},"Caveats"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"It is not possible to remove elements by id in a queue: items can only be removed by means of commit, pop or\nmove-to-deadletter"),(0,o.kt)("li",{parentName:"ul"},"An external, constant cleanup process is needed to remove exhausted artifacts from the mongodb collection modelling the\nqueue. A complete cleanup cannot be performed at the pop/commit without risking loss of items")))}d.isMDXComponent=!0}}]);