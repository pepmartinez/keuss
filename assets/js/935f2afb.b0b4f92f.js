"use strict";(self.webpackChunkkeuss_docusaurus=self.webpackChunkkeuss_docusaurus||[]).push([[53],{1109:function(e){e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"someSidebar":[{"type":"category","label":"Intro","items":[{"type":"link","label":"About","href":"/keuss/docs/","docId":"about"},{"type":"link","label":"Quickstart","href":"/keuss/docs/quickstart","docId":"quickstart"},{"type":"link","label":"Concepts","href":"/keuss/docs/concepts","docId":"concepts"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Usage","items":[{"type":"link","label":"Putting all together","href":"/keuss/docs/usage/putting-all-together","docId":"usage/putting-all-together"},{"type":"link","label":"Bucket-based backends","href":"/keuss/docs/usage/buckets","docId":"usage/buckets"},{"type":"link","label":"Shutdown","href":"/keuss/docs/usage/shutdown","docId":"usage/shutdown"},{"type":"link","label":"Using no signaller","href":"/keuss/docs/usage/no-signaller","docId":"usage/no-signaller"},{"type":"link","label":"Redis Connections","href":"/keuss/docs/usage/redis-conns","docId":"usage/redis-conns"},{"type":"category","label":"Pipelines","items":[{"type":"link","label":"About","href":"/keuss/docs/usage/pipelines/about","docId":"usage/pipelines/about"},{"type":"link","label":"Processors","href":"/keuss/docs/usage/pipelines/processors","docId":"usage/pipelines/processors"},{"type":"link","label":"Building","href":"/keuss/docs/usage/pipelines/building","docId":"usage/pipelines/building"},{"type":"link","label":"Examples","href":"/keuss/docs/usage/pipelines/examples","docId":"usage/pipelines/examples"}],"collapsed":true,"collapsible":true}],"collapsed":true,"collapsible":true},{"type":"category","label":"API","items":[{"type":"link","label":"Factory","href":"/keuss/docs/api/factory","docId":"api/factory"},{"type":"link","label":"Signaller","href":"/keuss/docs/api/signal","docId":"api/signal"},{"type":"link","label":"Stats","href":"/keuss/docs/api/stats","docId":"api/stats"},{"type":"link","label":"Queue","href":"/keuss/docs/api/queue","docId":"api/queue"}],"collapsed":true,"collapsible":true},{"type":"link","label":"Examples","href":"/keuss/docs/examples","docId":"examples"},{"type":"link","label":"Changelog","href":"/keuss/docs/changelog","docId":"changelog"}]},"docs":{"about":{"id":"about","title":"About","description":"Keuss is an attempt or experiment to provide a serverless, persistent and high-available queue middleware supporting delays/schedule, using mongodb and redis to provide most of the backend needs. As of now, it has evolved into a rather capable and complete queue middleware.","sidebar":"someSidebar"},"api/factory":{"id":"api/factory","title":"Factory API","description":"Backends, which work as queue factories, have the following operations:","sidebar":"someSidebar"},"api/queue":{"id":"api/queue","title":"Queue API","description":"stats: Queue stats","sidebar":"someSidebar"},"api/signal":{"id":"api/signal","title":"Signaller API","description":"Signaler factory","sidebar":"someSidebar"},"api/stats":{"id":"api/stats","title":"Stats API","description":"Stats factories","sidebar":"someSidebar"},"changelog":{"id":"changelog","title":"Changelog","description":"* v1.6.10","sidebar":"someSidebar"},"concepts":{"id":"concepts","title":"Concepts","description":"Queue","sidebar":"someSidebar"},"doc1":{"id":"doc1","title":"Style Guide","description":"You can write content using GitHub-flavored Markdown syntax."},"examples":{"id":"examples","title":"Examples","description":"A set of funcioning examples can be found inside the examples directory:","sidebar":"someSidebar"},"quickstart":{"id":"quickstart","title":"Quickstart","description":"Package Install","sidebar":"someSidebar"},"usage/buckets":{"id":"usage/buckets","title":"Bucket-based backends","description":"Up to version 1.4.X all backends worked in the same way, one element at a time: pushing and popping elements fired one or more operations per element on the underlying storage. This means the bottleneck would end up being the storage\'s I/O; redis and mongo both allow quite high I/O rates, enough to work at thousands of operations per second. Still, the limit was there.","sidebar":"someSidebar"},"usage/no-signaller":{"id":"usage/no-signaller","title":"Using no signaller","description":"Even when using signallers, pop operations on queue never block or wait forever; waiting pop operations are anyway terminated after 15000 millisecs","sidebar":"someSidebar"},"usage/pipelines/about":{"id":"usage/pipelines/about","title":"About","description":"Pipelines is a Keuss extension for building ETL processing graphs with ease while guaranteeing atomicity in the processing: whatever happens at the processing of an element, the element is guaranteed to be in either the source or in the destination queue; never in both, never in none.","sidebar":"someSidebar"},"usage/pipelines/building":{"id":"usage/pipelines/building","title":"Building Pipelines","description":"Pipelines can be built in 3 ways:","sidebar":"someSidebar"},"usage/pipelines/examples":{"id":"usage/pipelines/examples","title":"Examples","description":"* simplest: a very simple pipeline with just 2 queues connected with a DirectLink","sidebar":"someSidebar"},"usage/pipelines/processors":{"id":"usage/pipelines/processors","title":"Processors","description":"A small hierarchy of processors is provided with Pipelines:","sidebar":"someSidebar"},"usage/putting-all-together":{"id":"usage/putting-all-together","title":"Putting all together","description":"Factory initialization","sidebar":"someSidebar"},"usage/redis-conns":{"id":"usage/redis-conns","title":"Redis Connections","description":"Keuss relies on ioredis for connecting to redis. Anytime a redis connection is needed, keuss will create it from the opts object passed:","sidebar":"someSidebar"},"usage/shutdown":{"id":"usage/shutdown","title":"Shutdown","description":"It is a good practice to call close(cb) on the factories to release all resources once you\'re done, or at shutdown if you want your shutdowns clean and graceful (the log-lived redis or mongodb connections are terminated here, for example); also, you should loop over your queues and perform a drain() on them before calling close() on their factories: this will ensure any un-consumed data is popped, and any unwritten data is written. Also, it\'ll ensure all your (local) waiting consumers will end (on \'cancel\' error).","sidebar":"someSidebar"}}}')}}]);