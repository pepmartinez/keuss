<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.1">
<title data-rh="true">Modelling queues on MongoDB - II | Keuss Job Queues</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://pepmartinez.github.io/keuss/blog/2024/01/23/queues-on-mongo-part-2"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="Modelling queues on MongoDB - II | Keuss Job Queues"><meta data-rh="true" name="description" content="This is a continuation of Modelling queues on MongoDB - I, where"><meta data-rh="true" property="og:description" content="This is a continuation of Modelling queues on MongoDB - I, where"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2024-01-23T00:00:00.000Z"><meta data-rh="true" property="article:author" content="https://github.com/pepmartinez"><meta data-rh="true" property="article:tag" content="mongodb,tech"><link data-rh="true" rel="icon" href="/keuss/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://pepmartinez.github.io/keuss/blog/2024/01/23/queues-on-mongo-part-2"><link data-rh="true" rel="alternate" href="https://pepmartinez.github.io/keuss/blog/2024/01/23/queues-on-mongo-part-2" hreflang="en"><link data-rh="true" rel="alternate" href="https://pepmartinez.github.io/keuss/blog/2024/01/23/queues-on-mongo-part-2" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/keuss/blog/rss.xml" title="Keuss Job Queues RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/keuss/blog/atom.xml" title="Keuss Job Queues Atom Feed"><link rel="stylesheet" href="/keuss/assets/css/styles.248b806b.css">
<link rel="preload" href="/keuss/assets/js/runtime~main.56b230a5.js" as="script">
<link rel="preload" href="/keuss/assets/js/main.8d9596d6.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/keuss/"><div class="navbar__logo"><img src="/keuss/img/logo.svg" alt="Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/keuss/img/logo.svg" alt="Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Keuss job queues</b></a><a class="navbar__item navbar__link" href="/keuss/docs/">Docs</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/keuss/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/pepmartinez/keuss" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/keuss/blog/2024/01/23/queues-on-mongo-part-2">Modelling queues on MongoDB - II</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/keuss/blog/2024/01/22/queues-on-mongo-part-1">Modelling queues on MongoDB - I</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/keuss/blog/2020/08/04/welcome">New website!</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="title_f1Hy" itemprop="headline">Modelling queues on MongoDB - II</h1><div class="container_mt6G margin-vert--md"><time datetime="2024-01-23T00:00:00.000Z" itemprop="datePublished">January 23, 2024</time> · <!-- -->8 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/pepmartinez" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Pep Martinez</span></a></div></div></div></div></div></header><div id="__blog-post-container" class="markdown" itemprop="articleBody"><p>This is a continuation of <a href="/keuss/blog/2024/01/22/queues-on-mongo-part-1">Modelling queues on MongoDB - I</a>, where
we explained the technological basis on how to build a rather decent queue middleware by leveraging on preexisting
DB technologies, and adding very little more</p><p>Now, we explore how to push the technology further, building on top of what we got so far to add extra, useful
features</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="adding-delayschedule">Adding delay/schedule<a href="#adding-delayschedule" class="hash-link" aria-label="Direct link to Adding delay/schedule" title="Direct link to Adding delay/schedule">​</a></h2><p>This is a feature that is seldom found on QMWs, but that should be easy to implement if the
persistence is sound: after all, if you got the items safely stored, they can remain stored for
any arbitrary period of time</p><p>The tricky part is to provide this feature while honoring these conditions:</p><ul><li>performance should not degrade. Both push and pop should remain <code>O(1)</code></li><li>items awaiting should not block items that are ready</li></ul><p>On the other hand, this feature can be used to implement quite a lot of common logic, so it
<em>should</em> be high in the wishlist. Some examples are:</p><ul><li><a href="https://en.wikipedia.org/wiki/Exponential_backoff" target="_blank" rel="noopener noreferrer">exponential backoff</a> if whatever you do
with an item goes wrong and you want to retry later</li><li>simple scheduling of events or actions (<em>items</em> would model both)</li><li>with some extra logic, it&#x27;s easy to build a recurring or cron-like system, where items <em>happen</em>
periodically</li></ul><p>As it turns out, this is quite easy to model on MongoDB while still maintaining all the features
and capabilities of the <em>good enough queues</em> depicted before. The model can be expressed as:</p><table><thead><tr><th align="center">operation</th><th align="center">implementation base</th></tr></thead><tbody><tr><td align="center">push</td><td align="center"><code>coll.insertOne ({payload: params.item, when: params.when OR now()})</code></td></tr><tr><td align="center">pop</td><td align="center"><code>coll.findOneAndDelete({when &lt; now()}).payload</code></td></tr></tbody></table><p>One of the obvious changes is, we no longer insert the item as is: we encapsulate it inside an <em>envelope</em> where we put extra information; in this case, a timestamp stating when the object should start being elligible for a <code>pop</code> operation. Thus, the <code>pop</code> will only affect items whose <code>when</code> timestamp lies in the past, and ignore those with the timestamp still in the future</p><p>Then, in order to keep the performance close to <code>O(1)</code> we must be sure the collection has an index on <code>when</code>; moreover, it would be advisable to also order the <code>findOneAndDelete</code> operation by <code>when</code>, descending: this way we will add best-effort ordering, where elements with a longer-due timestamp are popped first</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="adding-reserve-commit-rollback">Adding reserve-commit-rollback<a href="#adding-reserve-commit-rollback" class="hash-link" aria-label="Direct link to Adding reserve-commit-rollback" title="Direct link to Adding reserve-commit-rollback">​</a></h2><p>A feture that should be offered on every decent QMW is the
ability to reserve an item, then process it and commit it once
done, or rollback it if something fails and we want it to be
retried later (or by other consumer)</p><p>This allows for what&#x27;s known as <em>at-least-once</em> semmantics:
every item in the queue is guaranteed to be treated at least
once even in the event of consumer failure. IT <em>does not</em>
guarantee lack of duplications, though. By contrast, the simple <em>pop</em> model provides <em>at_most_once</em> semantics: duplications are
guaranteed to not to happen, but at the cost of risk of item
loss if a consumer malfunctions</p><p>Reserve-commit-rollback model cam be expressed as the following extension of the
<em>delay/schedule</em> model above :</p><table><thead><tr><th align="center">operation</th><th align="center">implementation base</th></tr></thead><tbody><tr><td align="center">push</td><td align="center"><code>coll.insertOne ({payload: params.item, when: params.when OR now(), retries: 0, reserved: false})</code></td></tr><tr><td align="center">pop</td><td align="center"><code>coll.findOneAndDelete({when &lt; now()}).payload</code></td></tr><tr><td align="center">reserve</td><td align="center"><code>coll.findOneAndUpdate({when &lt; now()}, {when: (now() + params.timeout), reserved: true})</code></td></tr><tr><td align="center">commit</td><td align="center"><code>coll.delete({_id: params.reserved._id})</code></td></tr><tr><td align="center">rollback</td><td align="center"><code>coll.findOneAndUpdate({_id: params.reserved._id}, {when: (now() + params.delay), reserved: false, retries: $inc})</code></td></tr></tbody></table><p>The general idea is to leverage the existing scheduling fature: to reserve an element is just to set its <code>when</code>
time ahead in the future, by a fixed <code>timeout</code> amount; if the consumer is unable to process the element in this
time, the item will become elligible again for other consumers.</p><p>The <code>commit</code> operation simply deletes the entry by using the <code>_id</code> of the element returned by
<code>reserve</code>; and the <code>rollback</code> is a bit more complex: it modifies it to remove the <code>reserved</code> flag, increments
the <code>retries</code> counter and -most important- sets a <code>when</code> time further in the future. This last bit fulfills
the mprotant feature of adding delays to retries, so an element rejected by a consumer for further retry
will not be available immediately (when it is likely to fail again)</p><p>Note that the <code>reserved</code> flag is purely informational, although further checks could be done on it to improve
robustness. The same goes for <code>retries</code>: it just counts the number of retries; more logic could be added to this,
for example adding a <em>dead-queue</em> feature: if the number of retries goes too high the items are moved to a
separated queue for a more dedicated processing at a later time</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="queues-with-historic-data">Queues with historic data<a href="#queues-with-historic-data" class="hash-link" aria-label="Direct link to Queues with historic data" title="Direct link to Queues with historic data">​</a></h2><p>Here&#x27;s another twist: instead of fully removing items once consumed (by means f <code>pop</code> or <code>commit</code>), we just mark
them as deleted; then we keep them around for som etime, just in case we need to inspect past traffic, or replay
some items. This feature can be desirable on environments where the ability to inspect or even reproduce past traffic
is paramount. Also, this can be easily done at the expense of storage space only, with the following variation over
the model above:</p><table><thead><tr><th align="center">operation</th><th align="center">implementation base</th></tr></thead><tbody><tr><td align="center">push</td><td align="center"><code>coll.insertOne ({payload: params.item, when: params.when OR now(), retries: 0, reserved: false})</code></td></tr><tr><td align="center">pop</td><td align="center"><code>coll.findOneAndUpdate({when &lt; now(), processed: $nonexistent}, {processed: now(), when: $INF}).payload</code></td></tr><tr><td align="center">reserve</td><td align="center"><code>coll.findOneAndUpdate({when &lt; now(), processed: $nonexistent}, {when: (now() + params.timeout), reserved: true})</code></td></tr><tr><td align="center">commit</td><td align="center"><code>coll.update({_id: params.reserved._id}, {processed: now(), when: $INF})</code></td></tr><tr><td align="center">rollback</td><td align="center"><code>coll.findOneAndUpdate({_id: params.reserved._id}, {when: (now() + params.delay), reserved: false, retries: $inc})</code></td></tr></tbody></table><p>Then, we need to add a <a href="https://www.mongodb.com/docs/manual/core/index-ttl/" target="_blank" rel="noopener noreferrer">TTL index</a> on the new field <code>processed</code>, with
some long-enough expiration time</p><p>The main difference is the addition of a <code>processed</code> field that marks both whether the item was processed (that is <em>deleted</em>,
<em>no more</em>, <em>gone to meet its maker</em>) and if so, when that happened. This field is also used to delete old entries, once some
fixed time has elapsed. This means those queues can potentially grow very big, cause the condition to remove old entries is
age, and not size</p><p>Note that, in order to improve performance a bit, when an element is processed (after either <em>pop</em> or <em>commit</em>) its <em>when</em> is
set to some time far in the future, to move it &#x27;away&#x27; of the <em>get</em>/<em>reserve</em> query</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="queues-fit-for-etl-pipelines-moving-elements-from-one-queue-to-the-next-atomically">Queues fit for ETL pipelines: moving elements from one queue to the next, atomically<a href="#queues-fit-for-etl-pipelines-moving-elements-from-one-queue-to-the-next-atomically" class="hash-link" aria-label="Direct link to Queues fit for ETL pipelines: moving elements from one queue to the next, atomically" title="Direct link to Queues fit for ETL pipelines: moving elements from one queue to the next, atomically">​</a></h2><p>Htis is an interesting concept: one of the common uses of job queues is to build what&#x27;s known as ELT pipelines: a set of
computing stations where items are transformed or otherwise processed, connected with queues. A common example would be
a POSIX shell pipeline, where several commands are tied together so the output of one becomes the input of the next; a
ETL pipeline can have also forks and loops, so the topology can be generalized to a graph, not just a linear pipeline</p><p>Let us assume for a moment that messages are never created or duplicated in any station: in other words, an item entering
a station will produce zero or one items as output. In this scenario, oen of the reliability problems that arise is that,
usually, moving items from one (input) queue to the next (output) queue is not an atomic operation. This may lead to either item loss or item duplication in the case of station
malfunction, even if we use <code>reserve-commit</code></p><p>If we push to output after committing on input, we incur on risk of loss:</p><p>whereas if we push to output <em>before</em> commit on input, we risk duplication:</p><p>So, the <em>commit-in-input</em> and <em>push-on-output</em> operations must be done atomically; and it turns out it is quite simple
to extend the model to accomodate that as a new, atomic <em>move-to-queue</em> operation (although it comes at a price, as we
will see)</p><p>This new operation requires that <em>all</em> queues of a given pipeline have to be hosted in the same mongodb collection; so,
our item envelope grows to contain an extra field, <code>q</code>. Then, all operations are augmented to use this new field:</p><table><thead><tr><th align="center">operation</th><th align="center">implementation base</th></tr></thead><tbody><tr><td align="center">push</td><td align="center"><code>coll.insertOne ({q: params.qname, payload: params.item, when: params.when OR now(), retries: 0, reserved: false})</code></td></tr><tr><td align="center">pop</td><td align="center"><code>coll.findOneAndDelete({q: params.qname, when &lt; now()}).payload</code></td></tr><tr><td align="center">reserve</td><td align="center"><code>coll.findOneAndUpdate({q: params.qname, when &lt; now()}, {when: (now() + params.timeout), reserved: true})</code></td></tr><tr><td align="center">commit</td><td align="center"><code>coll.delete({_id: params.reserved._id})</code></td></tr><tr><td align="center">rollback</td><td align="center"><code>coll.findOneAndUpdate({_id: params.reserved._id}, {when: (now() + params.delay), reserved: false, retries: $inc})</code></td></tr></tbody></table><p>The new operation <em>move-to-queue</em> is expected to act upon a reserved item, and can be modelled as:</p><table><thead><tr><th align="center">operation</th><th align="center">implementation base</th></tr></thead><tbody><tr><td align="center">moveToQ</td><td align="center"><code>coll.findOneAndUpdate({_id: params.reserved._id}, {q: params.new_qname, reserved: false, retries: 0})</code></td></tr></tbody></table><p>The operation is rather similar to a rollback, and it is definitely atomic</p></div><footer class="row docusaurus-mt-lg blogPostFooterDetailsFull_mRVl"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/keuss/blog/tags/mongodb">mongodb</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/keuss/blog/tags/tech">tech</a></li></ul></div><div class="col margin-top--sm"><a href="https://github.com/pepmartinez/keuss/edit/master/website/blog/blog/2024-01-23-queues-on-mongo-part-2.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--next" href="/keuss/blog/2024/01/22/queues-on-mongo-part-1"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">Modelling queues on MongoDB - I</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#adding-delayschedule" class="table-of-contents__link toc-highlight">Adding delay/schedule</a></li><li><a href="#adding-reserve-commit-rollback" class="table-of-contents__link toc-highlight">Adding reserve-commit-rollback</a></li><li><a href="#queues-with-historic-data" class="table-of-contents__link toc-highlight">Queues with historic data</a></li><li><a href="#queues-fit-for-etl-pipelines-moving-elements-from-one-queue-to-the-next-atomically" class="table-of-contents__link toc-highlight">Queues fit for ETL pipelines: moving elements from one queue to the next, atomically</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Start Here</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/keuss/docs/quickstart">Quickstart</a></li><li class="footer__item"><a class="footer__link-item" href="/keuss/docs/">Documentation</a></li><li class="footer__item"><a class="footer__link-item" href="/keuss/docs/examples">Examples</a></li><li class="footer__item"><a class="footer__link-item" href="/keuss/docs/changelog">ChangeLog</a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/keuss/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/pepmartinez/keuss" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024. Built with Docusaurus.</div></div></div></footer></div>
<script src="/keuss/assets/js/runtime~main.56b230a5.js"></script>
<script src="/keuss/assets/js/main.8d9596d6.js"></script>
</body>
</html>